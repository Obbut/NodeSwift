

{% for protocol in types.protocols|annotated:"jsAvailable" %}

/**
Packs a JavaScript object conforming to the {{protocol.name}} protocol defined in Swift

@parameter {object} obj The object to pack
*/
function pack{{protocol.name}}(obj) {
  return {
    {% for var in protocol.allVariables %}
      {% if var.type.annotations.jsAvailable and var.type.kind == "protocol" %}
      {{ var.name }}: pack{{var.type.name}}(obj.{{var.name}})
      {% else %}
      {{ var.name }}: obj.{{ var.name }}
      {% endif %}
      {% if not forloop.last %},{% endif %}
    {% endfor %}
  };
}

{% endfor %}

var s = null;

/// All promises waiting for an answer are here
var messagePromises = {};
var nextMessageId = 0;
var buffer = Buffer.from([]);

/**
@returns {Promise}
*/
function swiftMessage(msg) {
  if (s == null) {
    s = require('net').Socket();
    s.connect(8403, 'localhost');

    s.on('data', chunk => {
      buffer = Buffer.concat([buffer, chunk]);

      let byteCount = buffer.length;
      if (byteCount < 4) return;

      let messageLength = buffer.readInt32LE(0);
      if (byteCount < 4+messageLength) return;

      let messageJSON = buffer.slice(4, 4+messageLength).toString();
      let message = JSON.parse(messageJSON);

      // truncate buffer
      buffer = buffer.slice(4+messageLength, byteCount-1);

      // handle message
      if (typeof messagePromises[message.id] == "object") {
        messagePromises.resolve(message);
      }
    });
  }

  // assign a new message id, for tracking the response
  msg.id = nextMessageId;
  nextMessageId++;

  var promiseObject = {};
  messagePromises[msg.id] = promiseObject;

  promiseObject.promise = new Promise((resolve, reject) => {
    promiseObject.resolve = resolve;
    promiseObject.reject = reject;

    let json = JSON.stringify(msg);

    let lenbuf = Buffer.allocUnsafe(4);
    lenbuf.writeInt32LE(json.length, 0);

    s.write(lenbuf);
    s.write(json);
  });

  // Remove the promise when finished.
  let cleanup = () => {
    messagePromises[msg.id] = undefined;
  };
  promiseObject.promise.then(cleanup, cleanup);

  return promiseObject.promise;
}

{% for type in types.all|annotated:"jsAvailable" %}

module.exports.{{type.name}} = {
  {% for method in type.allMethods|annotated:"jsAvailable" %}
    {{ method.shortName }}: function(
      {% for param in method.parameters %}
        {{ param.name }}{% if not forloop.last %},{% endif %}
      {% endfor %}
    ) {
      return swiftMessage({a: "callStatic", t: "{{type.name}}", m: "{{method.shortName}}",
        {% if method.parameters.count > 0 %}
        args: {
          {% for param in method.parameters %}
            {% if param.type.annotations.jsAvailable and param.type.kind == "protocol" %}
            {{ param.name }}: pack{{param.unwrappedTypeName}}({{param.name}})
            {% else %}
            {{ param.name }}
            {% endif %}
            {% if not forloop.last %},{% endif %}
          {% endfor %}
        }
        {% endif %}
      })
    },
  {% endfor %}
};

{% endfor %}
